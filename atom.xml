<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sinFuture</title>
  <subtitle>Like the front, like tossing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.Mmyton.com/"/>
  <updated>2017-05-22T16:27:04.000Z</updated>
  <id>http://www.Mmyton.com/</id>
  
  <author>
    <name>sinFuture(新的未来)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解剖jQuery源码系列之jQuery.prototype.init方法</title>
    <link href="http://www.Mmyton.com/2017/05/20/jQuery20170520/"/>
    <id>http://www.Mmyton.com/2017/05/20/jQuery20170520/</id>
    <published>2017-05-20T11:00:24.000Z</published>
    <updated>2017-05-22T16:27:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天日子是5月20号，比较特殊，原本打算出去浪一下，奈何对象有事。就静下心来把jQuery源码中的init方法总结下。篇幅会略长些。<a id="more"></a></p>
<h4 id="jQuery-prototype-init"><a href="#jQuery-prototype-init" class="headerlink" title="jQuery.prototype.init"></a>jQuery.prototype.init</h4><p>　　说起jQuery.prototype.init这个方法，不知道大家还有没有印象，这个方法在jQuery源码中出现在两个地方，什么作用呢？我们来看以下的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里出现了第一次</span></div><div class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context,          rootjQuery );</div><div class="line"><span class="comment">//这里是第二次</span></div><div class="line">jQuery.fn = jQuery.prototype = &#123;</div><div class="line">  <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context, rootjQuery </span>) </span>&#123;</div><div class="line">    <span class="comment">//中间省略无数代码，一会再来看</span></div><div class="line">  &#125;</div><div class="line">&#125;  </div></pre></td></tr></table></figure><br>　　从上可以看出来，init方法是jQuery原型上的一个方法。我们再来看下我们平时使用jQuery或者$创建jQuery对象有几种使用方式，大致可以分为以下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//$就是jQuery</span></div><div class="line"><span class="comment">//第一种分类</span></div><div class="line">$(<span class="string">""</span>), $(<span class="literal">null</span>), $(<span class="literal">undefined</span>), $(<span class="literal">false</span>)</div><div class="line"><span class="comment">//第二种分类</span></div><div class="line">$(<span class="string">'#div1'</span>) $(<span class="string">'.box'</span>) $(<span class="string">'div'</span>)  $(<span class="string">'#div1 div.box'</span>)</div><div class="line">$(<span class="string">'&lt;li&gt;'</span>)  $(<span class="string">'&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;'</span>) $(<span class="string">'&lt;li&gt;hhehe'</span>)</div><div class="line"><span class="comment">//第三种分类</span></div><div class="line">$(<span class="keyword">this</span>)  $(<span class="built_in">document</span>)</div><div class="line"><span class="comment">//第四种分类</span></div><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</div><div class="line"><span class="comment">//第五种分类</span></div><div class="line">$([])  $(&#123;&#125;)</div></pre></td></tr></table></figure><br>　　看到这里，可能会有点疑惑，这个跟init方法有什么关系，我们来看一个例子：$(‘#div1’)，当执行这段代码时，$也就是jQuery函数就会执行起来，传入参数，其中selector就是#div1，传入到函数体内后，selector参数传给了jQuery.fn.init( selector, context, rootjQuery )这个构造函数，并new一个这个构造函数的实例，new一个时就会执行init的方法，最终$(‘#div1’)返回的是init的一个实例对象。从以上逻辑可以看出init方法主要做的是根据$或者jQuery构造函数执行时传入不同参数做差异化处理后返回init实例。根据我们平时使用的，$(‘#div’)的作用在于选中页面id为div的元素，而selector由上面的代码可以看出，可以传入不同的参数，那么init方法是如何针对传入的不同selector参数选中不同的Dom元素或者执行某个函数或者做其他处理呢？我们来看下init方法的源码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">jQuery.fn = jQuery.prototype = &#123;</div><div class="line">  <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context, rootjQuery </span>) </span>&#123;</div><div class="line">    <span class="comment">// 方法进来定义两个变量，第一个变量是后续匹配selector为字符串时使用</span></div><div class="line">    <span class="comment">// 第二个参数主要用于存储document.getElementById获取到的Dom元素</span></div><div class="line">    <span class="keyword">var</span> match, elem;    </div><div class="line">    </div><div class="line">    <span class="comment">// 第一中分类处理: $(""), $(null), $(undefined), $(false)</span></div><div class="line">    <span class="comment">// 如果传进来的是这四种情况直接返回this，关于this是什么可往下看</span></div><div class="line">    <span class="keyword">if</span> ( !selector ) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 第二种分类处理：</span></div><div class="line">    <span class="comment">// $('#div1') $('.box') $('div')  $('#div1 div.box')</span></div><div class="line">    <span class="comment">// $('&lt;li&gt;')  $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') $('&lt;li&gt;hhehe')</span></div><div class="line">    <span class="comment">// 判断传进来的selector，例如$('#div1')，那么selector就是'#div1'</span></div><div class="line">    <span class="comment">// 如果判断为真则进入if语句，否则进入第67行的else if</span></div><div class="line">    <span class="comment">// 也就是我们上面分类的第二类可以进入</span></div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> selector === <span class="string">"string"</span> ) &#123;</div><div class="line">      <span class="comment">// 第二种分类进来后，再次筛选，判断是否是标签</span></div><div class="line">      <span class="comment">// 能进入if的有$('&lt;li&gt;')  $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') </span></div><div class="line">      <span class="comment">// 而我们知道这2种类型属于创建标签</span></div><div class="line">      <span class="keyword">if</span> ( selector.charAt(<span class="number">0</span>) === <span class="string">"&lt;"</span> &amp;&amp; selector.charAt( selector.length - <span class="number">1</span> ) === <span class="string">"&gt;"</span> &amp;&amp; selector.length &gt;= <span class="number">3</span> ) &#123;</div><div class="line">        <span class="comment">// 进入if后给match赋值一个数组，这个数组最终编程是</span></div><div class="line">        <span class="comment">// match = [ null, '&lt;li&gt;', null ];</span></div><div class="line">        <span class="comment">// match = [ null, '&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;' , null ];</span></div><div class="line">        match = [ <span class="literal">null</span>, selector, <span class="literal">null</span> ];</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 能进入else的有</span></div><div class="line">        <span class="comment">// $('#div1') $('.box') $('div')  $('#div1 div.box') $('&lt;li&gt;hhehe')</span></div><div class="line">        <span class="comment">// 这一部分后面有写，可翻到后面看</span></div><div class="line">        <span class="comment">// 最终match由两个取值</span></div><div class="line">        <span class="comment">// $('#div1')对应的match=[‘#div1’, null, ’div1‘]</span></div><div class="line">        <span class="comment">// $('&lt;li&gt;hhehe')对应的match为match=[‘&lt;li&gt;hhehe’, ‘&lt;li&gt;’, null]</span></div><div class="line">        <span class="comment">// $('.box') $('div')  $('#div1 div.box')对应的match为null</span></div><div class="line">        match = rquickExpr.exec( selector );</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 判断match是否存在，并且 match[1]存在或者不存在context这个执行上下文</span></div><div class="line">      <span class="comment">// 能进入if的有 $('&lt;li&gt;')  $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') $('&lt;li&gt;hhehe')这种属于match存在并且match[1]也存在</span></div><div class="line">      <span class="comment">// 还有$('#div1')，这种属于match存在，match[1]不存在，因为我们通过id获取元素是不需要执行上下文，因此context不需要传，为undefined，因此!context为真</span></div><div class="line">      <span class="keyword">if</span> ( match &amp;&amp; (match[<span class="number">1</span>] || !context) ) &#123;</div><div class="line">        <span class="comment">// 能通过if的有$('&lt;li&gt;')  $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') $('&lt;li&gt;hhehe')</span></div><div class="line">        <span class="keyword">if</span> ( match[<span class="number">1</span>] ) &#123;</div><div class="line">          <span class="comment">// 这段三目判断的原因在于我们在写创建标签时可以由如下两种写法(因为创建标签只能是通过document创建，所以执行上下文只能是document)</span></div><div class="line">          <span class="comment">// 第一种$('&lt;li&gt;','document')</span></div><div class="line">          <span class="comment">// 第二种$('&lt;li&gt;',$('document'))</span></div><div class="line">          <span class="comment">// 所以先判断执行上下文context是不是JQuery类型，也就是$('&lt;li&gt;',$('document'))这种情况，此时返回context[0]也就是$('document')[0]，其实就是'document'</span></div><div class="line">          <span class="comment">// 如果不是jQuery类型那么直接返回执行上下文context，也就是$('&lt;li&gt;','document')这种情况</span></div><div class="line">          context = context <span class="keyword">instanceof</span> jQuery ? context[<span class="number">0</span>] : context;</div><div class="line">          <span class="comment">// 这一块代码涉及到两个JQuery工具方法</span></div><div class="line">          <span class="comment">// jQuery.merge:合并数组使用的，如果第一个传参是this这种对象，那就是合并对象</span></div><div class="line">          <span class="comment">// jQuery.parseHTML:将Dom字符串转成数组，例如'&lt;li&gt;1&lt;/li&gt;'转完之后变成['li']</span></div><div class="line">          <span class="comment">// 后续篇幅有分析这两个方法</span></div><div class="line">          <span class="comment">// 最终的生成this对象，也就是jQuery对象</span></div><div class="line">          <span class="comment">// $('&lt;li&gt;') $('&lt;li&gt;hhehe')对应的this对象为&#123;0:'li',length:1,...其他属性&#125;</span></div><div class="line">          <span class="comment">// $('&lt;li&gt;')对应的this对象为&#123;0:'li',1:'li',length:2,...其他属性&#125;</span></div><div class="line">          jQuery.merge( <span class="keyword">this</span>, jQuery.parseHTML(match[<span class="number">1</span>],context &amp;&amp; context.nodeType ? context.ownerDocument || context : <span class="built_in">document</span>,<span class="literal">true</span>));</div><div class="line">          <span class="comment">// 创建标签带属性，只支持单标签$('&lt;li&gt;') $('&lt;li&gt;1&lt;/li&gt;')例如 $('&lt;li&gt;',&#123;title:'hi',html:'abcd'&#125;)</span></div><div class="line">          <span class="comment">// rsingleTag.test( match[1] ) 是否是单标签，如果是判断context是不是对象字面量，如果是才走if</span></div><div class="line">            <span class="keyword">if</span> ( rsingleTag.test( match[<span class="number">1</span>] ) &amp;&amp; jQuery.isPlainObject( context ) ) &#123;</div><div class="line">              <span class="comment">// for in循环下context这个对象字面量，给选中的元素添加上属性</span></div><div class="line">              <span class="keyword">for</span> ( match <span class="keyword">in</span> context ) &#123;</div><div class="line">                <span class="comment">// 判断context中的属性是不是JQuery的工具方法，如果是调用工具方法，传入这个属性的值给这个工具方法，如上面这里例子中的html属性</span></div><div class="line">                <span class="keyword">if</span> ( jQuery.isFunction( <span class="keyword">this</span>[ match ] ))&#123;</div><div class="line">                  <span class="comment">// 相当于$('li').html('abcd')</span></div><div class="line">                  <span class="keyword">this</span>[ match ]( context[ match ] );</div><div class="line">                <span class="comment">// 如果不是方法，那么直接走JQuery的工具方法attr，传入属性和属性值</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">// 相当于$('li').attr('title','hi')</span></div><div class="line">                  <span class="keyword">this</span>.attr( match, context[ match ] );</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 最后返回处理后的this对象，也就是JQuery对象</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        <span class="comment">// 处理的是: $('#div1')</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 通过原生的document.getElementById获取id所对应的Dom元素</span></div><div class="line">          elem = <span class="built_in">document</span>.getElementById( match[<span class="number">2</span>] );</div><div class="line">          <span class="comment">// 这个是兼容处理，这个兼容处理可忽略</span></div><div class="line">          <span class="comment">// 以下语句走完,例如有一个ul，id为ul，则this对象为&#123;ul#ul,length:1,context:document,selector:'#ul'&#125;</span></div><div class="line">          <span class="keyword">if</span> ( elem &amp;&amp; elem.parentNode ) &#123;</div><div class="line">            <span class="keyword">this</span>.length = <span class="number">1</span>;</div><div class="line">            <span class="keyword">this</span>[<span class="number">0</span>] = elem;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">this</span>.context = <span class="built_in">document</span>;</div><div class="line">          <span class="keyword">this</span>.selector = selector;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 以下开始处理: $('.box') $('div')  $('#div1 div.box')</span></div><div class="line">        <span class="comment">// 判断context存在不，不存在可以进入if里，如果存在，还需要判断是不是jQuery对象</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !context || context.jquery ) &#123;</div><div class="line">          <span class="comment">// 以下语句等价于</span></div><div class="line">          <span class="comment">// $('.box'):$(document).find('.box')</span></div><div class="line">          <span class="comment">// $('div'):$(document).find('div')</span></div><div class="line">          <span class="comment">// $('#div1 div.box'):$(document).find('#div1 div.box')</span></div><div class="line">          <span class="comment">// $('.box',$('ul')):$('ul').find('.box')</span></div><div class="line">          <span class="comment">// 其中find方法是sizzle模块中的一个方法</span></div><div class="line">          <span class="keyword">return</span> ( context || rootjQuery ).find( selector );</div><div class="line">        <span class="comment">// 处理比如$('.box','ul')</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 等价于$('ul').find('.box')</span></div><div class="line">          <span class="comment">// 其中this.constructor其实就是jQuery构造函数，这也就是为什么在jQuery原型中还需要修正下原型属性constructor指向jQuery构造函数的原因之一</span></div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.constructor( context ).find( selector );</div><div class="line">        &#125;</div><div class="line">      <span class="comment">// 处理第三种分类: $(document) $(this)</span></div><div class="line">      <span class="comment">// 返回的this对象为&#123;0:document,context:document,length:1&#125;</span></div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( selector.nodeType ) &#123;</div><div class="line">        <span class="keyword">this</span>.context = <span class="keyword">this</span>[<span class="number">0</span>] = selector;</div><div class="line">        <span class="keyword">this</span>.length = <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">      <span class="comment">// 处理第四种分类: $(function()&#123;&#125;)</span></div><div class="line">      <span class="comment">// 以下说明平时我们这么写$(function()&#123;&#125;)和$(document).ready(function()&#123;&#125;)是等价的</span></div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( jQuery.isFunction( selector ) ) &#123;</div><div class="line">        <span class="keyword">return</span> rootjQuery.ready( selector );</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 处理 $($("ul"))</span></div><div class="line">      <span class="keyword">if</span> ( selector.selector !== <span class="literal">undefined</span> ) &#123;</div><div class="line">        <span class="keyword">this</span>.selector = selector.selector;</div><div class="line">        <span class="keyword">this</span>.context = selector.context;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 处理第五种：$(&#123;&#125;),$([])</span></div><div class="line">      <span class="keyword">return</span> jQuery.makeArray( selector, <span class="keyword">this</span> );</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　今天日子是5月20号，比较特殊，原本打算出去浪一下，奈何对象有事。就静下心来把jQuery源码中的init方法总结下。篇幅会略长些。
    
    </summary>
    
      <category term="前端技术" scheme="http://www.Mmyton.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.Mmyton.com/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://www.Mmyton.com/tags/jQuery/"/>
    
      <category term="Dom" scheme="http://www.Mmyton.com/tags/Dom/"/>
    
  </entry>
  
  <entry>
    <title>浅谈项目中经常需要使用到的less功能</title>
    <link href="http://www.Mmyton.com/2017/04/27/less/"/>
    <id>http://www.Mmyton.com/2017/04/27/less/</id>
    <published>2017-04-27T14:11:48.000Z</published>
    <updated>2017-04-27T14:22:52.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="前端技术" scheme="http://www.Mmyton.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="less" scheme="http://www.Mmyton.com/tags/less/"/>
    
      <category term="css" scheme="http://www.Mmyton.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>从统计分析自动生成系统看gulp的自动化构建</title>
    <link href="http://www.Mmyton.com/2017/04/27/gulp/"/>
    <id>http://www.Mmyton.com/2017/04/27/gulp/</id>
    <published>2017-04-27T14:11:32.000Z</published>
    <updated>2017-04-27T14:21:26.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="前端技术" scheme="http://www.Mmyton.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="gulp" scheme="http://www.Mmyton.com/tags/gulp/"/>
    
      <category term="npm" scheme="http://www.Mmyton.com/tags/npm/"/>
    
      <category term="jade" scheme="http://www.Mmyton.com/tags/jade/"/>
    
      <category term="javascript" scheme="http://www.Mmyton.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础项目构建</title>
    <link href="http://www.Mmyton.com/2017/04/27/es6/"/>
    <id>http://www.Mmyton.com/2017/04/27/es6/</id>
    <published>2017-04-27T14:11:17.000Z</published>
    <updated>2017-04-27T14:16:51.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="前端技术" scheme="http://www.Mmyton.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://www.Mmyton.com/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://www.Mmyton.com/tags/JavaScript/"/>
    
      <category term="gulp" scheme="http://www.Mmyton.com/tags/gulp/"/>
    
      <category term="npm" scheme="http://www.Mmyton.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>解剖jQuery源码系列之JQuery构造函数</title>
    <link href="http://www.Mmyton.com/2017/04/27/jquery20170427/"/>
    <id>http://www.Mmyton.com/2017/04/27/jquery20170427/</id>
    <published>2017-04-27T07:51:02.000Z</published>
    <updated>2017-05-20T10:56:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　jQuery从2006年由John Resig等人创建一直风靡到今天，每个在使用jQuery时，应该都深深的被其便捷性的Dom操作，数据缓存，异步操作等折服，jQuery的api设计让我们可以如此的简单自如的操作web界面，如果你没有感受到，那你应该面壁思过下。<a id="more"></a></p>
<h4 id="jQuery整体架构"><a href="#jQuery整体架构" class="headerlink" title="jQuery整体架构"></a>jQuery整体架构</h4><p>　　说到jQuery的架构，可以点击右边图片来感受下：<img src="/images/jquery.png" width="16"><br>　　其实jQuery的整体架构还是很清晰（虽然各个模块具体源码看起来感觉也挺乱的）。通过这张图我们大概可以把jQuery分为18块内容。整个jQuery最核心的代码用匿名函数包起来，具体可参考上一篇文章：<a href="http://www.mmyton.com/2017/04/25/jquery20170425/">解剖JQuery源码系列之匿名函数自执行</a><br>　　接着上一篇我们继续来说，这个主要是因为ES5中只有函数作用域和全局作用域，并无块级作用域。jQuery设计时为了不影响全局作用域，以及不同脚本文件引入后互相影响，选择了匿名函数，我们都知道匿名函数自执行（也就是Immediately-Invoked Function Expression (IIFE)），函数体定义的变量以及函数属于局部变量和局部函数，不会影响到全局作用域里定义的同名变量和函数。全局作用域也访问不到这些局部变量和函数，有点类似私有的意味。jQuery设计者也是基于此而采用这种方式。<br>　　那么问题来了，既然匿名函数里的变量和函数全局作用域访问不到，那么我们平时为什么可以直接在我们的js中引用jQuery的各种方法呢？我们来看如下的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//jQuery2.0.3版本</span></div><div class="line"><span class="comment">//这个就是jQuery匿名函数</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</div><div class="line">  <span class="comment">//判断是nodejs等common.js（CMD）规范的环境</span></div><div class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="built_in">module</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span> ) &#123;</div><div class="line">    <span class="comment">//通过exports导出</span></div><div class="line">    <span class="built_in">module</span>.exports = jQuery;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">//判断是否是AMD这种模块化环境</span></div><div class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd ) &#123;</div><div class="line">    <span class="comment">//定义jquery模块</span></div><div class="line">    define( <span class="string">"jquery"</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> jQuery; &#125; );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">  <span class="comment">//if判断主要是确定下window和window.document是不是对象，也就是不是AMD、CMD等模块化环境，如果是对象就把JQuery挂载到全局对象window上</span></div><div class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span>.document === <span class="string">"object"</span> ) &#123;</div><div class="line">	 <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;<span class="comment">//秘密就在这一行代码。</span></div><div class="line">  &#125;</div><div class="line">&#125;)( <span class="built_in">window</span> );</div></pre></td></tr></table></figure><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//jQuery3.2.1版本</span></div><div class="line"><span class="comment">//这个就是jQuery匿名函数</span></div><div class="line">( <span class="function"><span class="keyword">function</span>(<span class="params"> global, factory </span>) </span>&#123;</div><div class="line"><span class="meta">  "use strict"</span>;</div><div class="line">  <span class="comment">//这是判断如果是nodejs环境的导出方式</span></div><div class="line">  <span class="comment">//与2.0.3版本的区别就是module.exports导出的不是jQuery构造函数，</span></div><div class="line">  <span class="comment">//而是factory这个函数，也就是我们匿名函数传参的第二个参数function( window, noGlobal) &#123;&#125;</span></div><div class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span> ) &#123;</div><div class="line">  <span class="built_in">module</span>.exports = global.document ?</div><div class="line">      factory( global, <span class="literal">true</span> ) :</div><div class="line">	  <span class="function"><span class="keyword">function</span>(<span class="params"> w </span>) </span>&#123;</div><div class="line">		 <span class="keyword">if</span> ( !w.document ) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"jQuery requires a window with a document"</span> );</div><div class="line">		 &#125;</div><div class="line">		 <span class="keyword">return</span> factory( w );</div><div class="line">	  &#125;;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">	  factory( global );</div><div class="line">  &#125;</div><div class="line">&#125;)( <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>, </div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"> window, noGlobal </span>) </span>&#123;</div><div class="line">  <span class="comment">//判断如果是AMD模块化的环境就走if里的语句定义一个jquery模块</span></div><div class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd ) &#123;</div><div class="line">	define( <span class="string">"jquery"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> jQuery;</div><div class="line">	&#125; );</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//这个判断上一篇文章已有涉及，这里就不在赘述</span></div><div class="line">  <span class="keyword">if</span> ( !noGlobal ) &#123;</div><div class="line">	<span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> jQuery;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><br>　　我们之所以可以在全局作用域里自如的使用的jQuery的方法，是因为如上代码的，将jQuery这个构造函数根据不同环境采用不同的方式引用（为什么说是构造函数，我们后续再分析），例如：挂载在全局对象window上，这样我们在任何js文件里都可以引用jQuery的方法了。（看到这里估计你还是晕的，没关系，再往下看你就明白了。）</p>
<h4 id="jQuery构造函数"><a href="#jQuery构造函数" class="headerlink" title="jQuery构造函数"></a>jQuery构造函数</h4><p>　　在分析jQuery构造函数，我们先来看下原生js中的面向对象，以下是我们一般在写面向对象的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个就是构造函数（说白点就是函数）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">suhq</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//这里写一些实例属性和方法，非共享。</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//通过在suhq的原型（suhq.prototype）上写些suhq实例共享的属性和方法</span></div><div class="line">suhq.prototype.init=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//这里主要是new一个新实例时需要初始化的相关内容。</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//这个就是实例共享的方法</span></div><div class="line">suhq.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> s1=<span class="keyword">new</span> suhq();<span class="comment">//创建实例</span></div><div class="line">s1.init();<span class="comment">//初始化</span></div><div class="line">s1.say();<span class="comment">//调用原型上的共享方法</span></div></pre></td></tr></table></figure><br>　　其实，js中是没有如同java中类这种面向对象语法的（ES6引入了），那js中是如何实现面向对象的呢？如上代码所示，js是通过原型来模拟java中类的行为，然后new一个实例出来，这个实例不仅可以拥有构造函数的实例属性，也可以访问原型上的共享属性与方法。如果jQuery按照这样写的应该如何写？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">jQuery.prototype.init=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">jQuery.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>　　接下去调用的方法和上面是一样的，但是我们用过jQuery都知道jQuery是这么调用的，例如$().say()或者jQuery().say()或者$.each()，那jQuery是如何写的呢？我们来看如下的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context,        rootjQuery );</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>　　jQuery的写法和我们一般写面向对象不太一样，为什么这么说呢？我们来看下jQuery构造函数里返回的是什么？返回的是jQuery.fn.init()这个init构造函数的实例，看到这一句，是不是有点懵逼，按照js原生面向对象的写法，jQuery构造函数应该是在这个函数里写一些实例独有的属性与方法，为什么直接返回这么一个实例对象？而且我们平时调用jQuery的API时明明是这么调用的，例如：$(‘div’).css(“background”,”red”);，再比如:$.each(function(item){});等，按照这样的调用方法，第一种调用看起来像是调用的是原型上的方法，第二种看起来像是调用构造函数的实例方法。可源码中写的却是返回这么一个实例。而且我们调用API貌似都没new一下产生实例对象，就能调用jQuery的各种API，是不是感觉很神奇，其实这恰恰是JQuery能这么火的原因之一。这个我们叫做jQuery无new操作。接下去我们来分析，jQuery是如何做到这一点的。</p>
<h4 id="jQuery无NEW操作符"><a href="#jQuery无NEW操作符" class="headerlink" title="jQuery无NEW操作符"></a>jQuery无NEW操作符</h4><p>　　我们在前面写的suhq这个构造函数，调用时需要new suhq()一下产生一个suhq的实例对象，而我们平时在调用时却不需要，原因是因为jQuery构造函数里写的这么一句话<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</div><div class="line">    <span class="comment">//就是这一句代码</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context, rootjQuery );</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>　　那是因为从jQuery构造函数中的代码可以看出jQuery已经帮我们做了这么一个new操作了。但是new的却是init的实例对象，而不是jQuery的实例，那么我们平时调用时是如何能访问到jQuery原型上的方法呢？为了更好的理解这个意思，我们举个例子，比如：$(“div”).css(“background”,”red”)其中”div”就是selector参数的实参，执行$(“div”)这个操作（按照jQuery构造函数写的）返回的是init构造函数的一个实例对象，那么css这个方法要么是init构造函数的实例方法或者是原型方法，但是我们如果稍微了解下jQuery如何写插件和扩展方法就知道，css这个方法其实是jQuery原型上的一个方法。其实，奥秘就在如下代码中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这是一段在匿名函数中的两行代码</span></div><div class="line">jQuery.fn = jQuery.prototype = &#123;&#125;;</div><div class="line">jQuery.fn.init.prototype = jQuery.fn;</div></pre></td></tr></table></figure><br>　　　第一句是jQuery.fn指向了jQuery.prototype，话句话说fn就是prototype，第二句是jQuery.fn.init的原型指向了jQuery.fn也就是指向了jQuery.prototype，简单点就是init构造函数被重写成了jQuery的原型，所以init的实例对象才能访问到jQuery对象的属性与方法（因为构造函数new一个对象时就会在实例对象上创建一个属性(<strong>proto</strong>)指向原型，我们在访问实例对象的属性或者方法时，如果实例对象本身没有，就会朝着(<strong>proto</strong>)指向的原型上找）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　jQuery从2006年由John Resig等人创建一直风靡到今天，每个在使用jQuery时，应该都深深的被其便捷性的Dom操作，数据缓存，异步操作等折服，jQuery的api设计让我们可以如此的简单自如的操作web界面，如果你没有感受到，那你应该面壁思过下。
    
    </summary>
    
      <category term="前端技术" scheme="http://www.Mmyton.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jQuery" scheme="http://www.Mmyton.com/tags/jQuery/"/>
    
      <category term="Dom" scheme="http://www.Mmyton.com/tags/Dom/"/>
    
      <category term="javaScript" scheme="http://www.Mmyton.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>解剖jQuery源码系列之匿名函数自执行</title>
    <link href="http://www.Mmyton.com/2017/04/25/jquery20170425/"/>
    <id>http://www.Mmyton.com/2017/04/25/jquery20170425/</id>
    <published>2017-04-24T16:49:46.000Z</published>
    <updated>2017-05-07T03:16:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近公司开始逐步放弃掉了支持IE8，转而从IE9支持起，jQuery版本也从1.8.0开始需要升级到2.0+以上，工作中用到jQuery也蛮多的，刚好最近不是很忙打算梳理下jQuery的相关内容。<a id="more"></a><br>　　相比于最近前端界流行的vue、react、angular等等框架，jQuery的热度再也不像之前那么火热，甚至有种被遗弃的感觉，很多人开口闭口都是各种新出的框架。记得老大说过，技术其实要适应生产环境才是最重要的。很多时候在工作中遇到问题更多的是基础的问题，远远谈不到这个框架的优劣。ES5仍然博大精深。本系列主要分析jQuery2.0.3版本，也会加上最新版jQuery3.2.1的相应解剖。</p>
<blockquote>
<p>框架总有过时的时候，基础才是真材实料。</p>
</blockquote>
<h3 id="jQuery2-0-3匿名函数"><a href="#jQuery2-0-3匿名函数" class="headerlink" title="jQuery2.0.3匿名函数"></a>jQuery2.0.3匿名函数</h3><p>　　其实，开始看jQuery源码，真的蛮头疼的，细细品味下来，再结合工作中遇到的各种坑。体会还是蛮多的，以下是2.0.3版本源码抽出来的，整个源码就是包在一个匿名函数里，让这个匿名函数自执行。说到匿名函数，我们首先要知道js中定义函数的几种方式（顺便复习下基础）：<br>　　第一种，经常使用，比较常规：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(a)</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>　　第二种，利用构造函数Function，需要传入两个参数：1.函数参数列表2.函数体。这种写法在函数体很多的时候特别不方便，不建议这么写。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func=<span class="keyword">new</span> <span class="built_in">Function</span>(a,<span class="string">'console.log(a);'</span>)</div></pre></td></tr></table></figure>　　<br>　　第三种，匿名函数定义赋给变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func=<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>　<br>　　了解了js中函数的定义的几种方法，我们再来看下匿名函数自执行的几种定义形式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.jQuery的写法</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//这边是jQuery的核心代码</span></div><div class="line"></div><div class="line">&#125;)( <span class="built_in">window</span> );</div><div class="line"></div><div class="line"><span class="comment">//2.其他写法，这种写法在IE8下会出现问题，undefined可以定义为变量，修改成其他值。IE9以上和高级浏览器，undefined都不可以修改。</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window,undefined</span>) </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//这边是jQuery的核心代码</span></div><div class="line"></div><div class="line">&#125;)( <span class="built_in">window</span>, <span class="literal">undefined</span>);</div><div class="line"></div><div class="line"><span class="comment">//3.这种写法和第一种其实是一样的。</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined</span>) </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//这边是jQuery的核心代码</span></div><div class="line"></div><div class="line">&#125;( <span class="built_in">window</span>));</div></pre></td></tr></table></figure><br>　　从以上来看，匿名函数自执行简单的说就是定义一个匿名函数，然后立即执行，在原生js里的语法是把匿名函数包在一对()里，然后按照函数的正常调用传参数即可，jQuery就是采用这种方式，匿名函数传了一个实参window，为什么要传window这个全局对象呢？其实这个跟我们js查找变量所走的作用域有关系，分析后主要有2个原因：<br>　　1.匿名函数里用到window这个全局对象，不需要沿着作用域一层层往上去查找，直接在传参中获取，提高了获取window对象的速度。<br>　　2.方便压缩，实参传入形参（普及下实参和形参的概念，实参就是你传入函数实际传入的值，形参就是你定义函数时，函数的参数。），形参就可以直接压缩成一个字母w。<br>　　那为什么jQuery匿名函数还要传入第二个参数呢？我也总结了有两个原因：　　<br>　　1.匿名函数内部需要用到，undefined的值，可以从变量的角度来理解，因为匿名函数自执行时并没有传这个参数，函数中没有传参数，这个值默认为undefined。相比较第2种写法，undefined放在函数的形参里，实参不传，主要是为了兼容IE下的bug：可以定义undefined并修改它的值。<br>　　2.方便压缩成字母u。</p>
<h3 id="jQuery3-2-1架构（最新版）"><a href="#jQuery3-2-1架构（最新版）" class="headerlink" title="jQuery3.2.1架构（最新版）"></a>jQuery3.2.1架构（最新版）</h3><p>　　这个版本的整体写法改了风格，但是其实内容和原理变化不大，主要做了兼容Node、sea.js等符合Common.js规范或者类似Common.js规范的js框架。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> global, factory </span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span> ) &#123;</div><div class="line">        <span class="comment">// For CommonJS and CommonJS-like environments where a proper window is present,</span></div><div class="line">        <span class="comment">// execute the factory and get jQuery</span></div><div class="line">        <span class="comment">// For environments that do not inherently posses a window with a document</span></div><div class="line">        <span class="comment">// (such as Node.js), expose a jQuery-making factory as module.exports</span></div><div class="line">        <span class="comment">// This accentuates the need for the creation of a real window</span></div><div class="line">        <span class="comment">// e.g. var jQuery = require("jquery")(window);</span></div><div class="line">        <span class="comment">// See ticket #14549 for more info</span></div><div class="line">        <span class="built_in">module</span>.exports = global.document ?</div><div class="line">            factory( global, <span class="literal">true</span> ) :</div><div class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"> w </span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> ( !w.document ) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"jQuery requires a window with a document"</span> );</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> factory( w );</div><div class="line">            &#125;;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        factory( global );</div><div class="line">    &#125;</div><div class="line"><span class="comment">// Pass this if window is not defined yet</span></div><div class="line">&#125;(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> window, noGlobal </span>) </span>&#123;  </div><div class="line">　　　　<span class="comment">//说白了这里就是写各种JQ各种功能函数的地方，大概有一万多行</span></div><div class="line">&#125;));</div></pre></td></tr></table></figure><br>　　最新版的jQuery写法稍微修改了下，其实大体是一样的，我们先简化如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> global, factory </span>) </span>&#123;</div><div class="line">    <span class="comment">//这里先不看</span></div><div class="line">&#125;(a,b);</div></pre></td></tr></table></figure><br>　　整个函数就是个匿名函数自执行。其中，<br>　　a参数为三目运算（typeof window !== “undefined” ? window : this），这个是判断当前运行环境是否支持window这个全局对象，主要是为了兼容node.js等类似common.js规范环境，例如nodejs中的全局对象是global，当nodejs某一个模块不支持window时，这个参数就是this也就是global。<br>　　b参数为:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"> window, noGlobal </span>) </span>&#123;  </div><div class="line">　　<span class="comment">//说白了这里就是写各种JQ各种功能函数的地方，大概有一万多行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br>　　分析了下这两个参数，我们再来看下这个匿名函数的函数体。首行的判断语句：if ( typeof module === “object” &amp;&amp; typeof module.exports === “object” ) 。玩过node.js就知道module和module.exports就是nodejs用来创建模块并输出模块对象的方法。若此条件成立，if里执行的代码就是用来兼容nodejs。我们来看支持的情况下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="built_in">module</span>.exports = global.document ?       <span class="comment">//三目运算符，先判断当前环境是否支持window.document属性</span></div><div class="line">    <span class="comment">//（注意我们上面提到过形参global的实参是window）</span></div><div class="line">    factory( global, <span class="literal">true</span> ) :            <span class="comment">//支持的话就好办啦，常规的浏览器一般都是支持的，那就直接module.exports = factory( global, true )，</span></div><div class="line">    <span class="comment">//把JQ后面那一万多行的功能函数扩展到node.js里面。（注意我们上面提到过形参factory的实参是实现JQ各种功能的一个外部函数）</span></div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"> w </span>) </span>&#123;          <span class="comment">//如果当前环境不支持window.document属性，那就写个函数扔个Error说这环境不适用JQ，但依旧返回JQ的功能函数（但大部分估计是不能用的了）</span></div><div class="line">        <span class="keyword">if</span> ( !w.document ) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"jQuery requires a window with a document"</span> );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> factory( w );</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>　　如果我们使用的环境不是node.js等类似common.js规范环境，那么if ( typeof module === “object” &amp;&amp; typeof module.exports === “object” ) 这个判断就为false，走else，直接执行factory( global );<br>　　看到以上的分析，是否有一个参数，大家会觉得略奇怪些：noGlobal，这个是做什么用的？全局搜索了下jQuery源码，发现有用到的地方就是如下了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Expose jQuery and $ identifiers, even in AMD</span></div><div class="line"><span class="comment">// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)</span></div><div class="line"><span class="comment">// and CommonJS for browser emulators (#13566)</span></div><div class="line"><span class="keyword">if</span> ( !noGlobal ) &#123;</div><div class="line">	<span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>　　当noGlobal为假（也就是浏览器环境）时才执行if里的语句，把jQuery挂载在window下，从以上代码我们也可以看出来，jQuery和$是等价的，都指向jQuery对象。如果为真（那就是类似nodej或者其他类似AMD和CommonJS的环境里），就不执行if里的语句，那么其他环境如何使用到jQuery的相关方法呢？在整个源码的最后有一句代码：return jQuery;根据前面分析的匿名函数传参以及return jQuery;这一句代码，我们在nodejs环境中应该按照如下的方式调用(当然如果你改写了下jQuery那也可以用别的方式引入，这边就不说了)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $=<span class="built_in">require</span>(<span class="string">'jquery'</span>)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure>　　<br>　　以上就是这两个版本中采用的匿名函数自执行。当然采用匿名函数自执行最大的目的就是匿名函数内部都是局部变量，不会污染全局作用域。当页面引用多个库时也能很好的避免变量重名，函数重名等等一系列问题。<br>　　此篇分享先到此，接下去还会其他系列的分享。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　最近公司开始逐步放弃掉了支持IE8，转而从IE9支持起，jQuery版本也从1.8.0开始需要升级到2.0+以上，工作中用到jQuery也蛮多的，刚好最近不是很忙打算梳理下jQuery的相关内容。
    
    </summary>
    
      <category term="前端技术" scheme="http://www.Mmyton.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jQuery" scheme="http://www.Mmyton.com/tags/jQuery/"/>
    
      <category term="Dom" scheme="http://www.Mmyton.com/tags/Dom/"/>
    
      <category term="javaScript" scheme="http://www.Mmyton.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>点滴的生活就是幸福</title>
    <link href="http://www.Mmyton.com/2017/04/24/sinFuture/"/>
    <id>http://www.Mmyton.com/2017/04/24/sinFuture/</id>
    <published>2017-04-23T16:07:00.000Z</published>
    <updated>2017-05-06T06:00:49.000Z</updated>
    
    <content type="html"><![CDATA[  <blockquote class="blockquote-center"><p>我把我新博客第一篇文章给了人生中最重的事！</p>
</blockquote>
  <a id="more"></a>
  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=190563&auto=1&height=66"></iframe>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;我把我新博客第一篇文章给了人生中最重的事！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活" scheme="http://www.Mmyton.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://www.Mmyton.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
