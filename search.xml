<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[解剖jQuery源码系列之$.extend与$().extend方法]]></title>
      <url>%2F2017%2F05%2F31%2FjQuery20170531%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[你应该知道的HTTP首部之通用首部字段]]></title>
      <url>%2F2017%2F05%2F30%2Fhttp20170530%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[你应该掌握的14种常用的HTTP状态码]]></title>
      <url>%2F2017%2F05%2F29%2FhttpCode%2F</url>
      <content type="text"><![CDATA[最近在看《图解HTTP》这本书，书很薄，大概250页左右，阅读起来比较轻松，虽然有些理论平时项目中并没遇到，但是总体感觉还是很不错的一本书。 HTTP状态码 所谓的HTTP状态码，我个人认为是服务器在接收客户端请求处理结果的反馈，就是告知浏览器，服务器处理了你的请求，结果是怎么样的。说到这个状态码，印象最深刻还是美团校招面试时，问的我常见的状态码有几种分别做什么用。非科班出身的我，当时回答的还是项目中常遇到的那几个，比如200、500,其他，其他是什么，我也不知道。工作中遇到各种不同的状态码，不同的服务器请求结果，才让我有很深刻的意识，我应该掌握好HTTP。以下是状态码的类别： 类别 原因短语 1XX Information（信息性状态码） 接收的请求正在处理 2XX Success （成功状态码） 请求正常处理完毕 3XX Redirection （重定向状态码） 需要进行附加操作以完成请求 4XX Client Error （客户端错误状态码） 服务器无法处理请求 5XX Server Error （服务器错误状态码） 服务器处理请求出错 这里要特别提一句：只要符合状态码的类别即可。很多时候我在项目中遇到的状态码更多的根据我们的业务需求去划分，根据不同的返回错误提示，给出不同的状态码。但大体不会超出以下将要列出的状态码。 2XX 成功 2XX的响应结果就是表示服务器正常处理了请求。但是有时候也会遇到一种情况那就是后端返回状态码200，但是返回了错误提示，后端是将错误提示和状态码放在返回的字符串数据里：{code:404,message:”找不到taskId为38456的工单”}，这种情况下返回的状态码不可信，需要和后端规范下，请求返回的正确格式。 200 OK 这个状态码是我们平时遇到最多的，可以说经常遇到，简单点的意思就是说，服务器对于浏览器的请求完全理解并正确处理了。 这个状态码返回的内容跟请求方式有关系，如果是GET请求，返回包含响应主体，如果是HEAD请求，返回不包括响应主体。 204 No Content 这个状态码，看右边的原因短语，顾名思义，表示的是服务器已经正确并成功处理了浏览器的请求，但是返回的响应报文中不包含实体的主体部分。另外，也不允许返回任何实体的主体。（有点绕）当浏览器发出请求，如果服务器返回的是这个状态码，而此时页面又有展示，那么显示的页面不发生更新，因为没有新的主体返回。 这个状态码一般的使用场景是当客户端向服务器端发送请求，而且服务器不需要向客户端发送新内容的场景下。 206 Partial Content 这个状态码比较好理解，浏览器向服务器进行了返回内容的范围请求，比如只需要某一篇文章的50%，请求方会在请求首部设置范围字段Range，告知服务器我要请求哪一部分的内容，服务器收到请求后会返回这个返回的数据，并在响应报文里的字段Content-Range里显示了当前返回的数据范围。 3XX 重定向 3XX表示服务器需要执行某些特殊的处理才能以正确的方式响应请求。 301 Moved Permanently 理解这个最好的例子就是，你在浏览器收藏了某一个页面的书签，或者某一个资源的书签，当你下次请求时，服务器告知你需要重定向到另一个地址去获取这个页面或者资源，并告知你浏览器的书签也需要更新（当然更不更新取决于你）。浏览器更新的URI地址取于服务器返回的响应报文里的Location字段。 例如我们经常会请求这么一个地址：http://www.Mmyton.com/sample 也就是后续不加上斜杠，此时服务器就会告知浏览器重定向到 http://www.Mmyton.com/sample/ 这个地址请求资源，这时候就会产生301状态码。 302 Found 临时重定向。它和301很像，301是永久重定向，302状态码的意思是浏览器请求的资源已经被分配到新的URI了，希望浏览器这次的请求使用新的URI访问。既然是临时，也就是说它并不会要求你更新浏览器书签里这个页面或者资源的URI地址，后续是否会继续临时重定向到这个URI地址得看服务器是如何分配的。服务器返回的响应报文里的Location字段仍然是你之前书签里保存的那个地址。 303 See Other 书中的解释：该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。这个解释其实和302很像，感觉好想都是重定向，其实还是有明确的区别的，302虽然也重定向，但并没有要求浏览器特定采用什么请求方式，请求页面或者资源新的URI地址，但是303就明确要求使用GET方式，这个就是它们之间最大的区别。 304 Not Modified 这个状态码虽然划分到3XX系列里，但和重定向没有任何关系，它也是我们经常会遇到的一个状态码，它表示客户端发送附带条件的请求（指的是客户端采用GET方法的请求报文中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）时，服务器允许请求访问资源，但因发生请求资源未满足条件的情况后，直接返回304 Not Modified。其实就是资源没有改变，可以直接使用客户端未过期的缓存，这也是为什么我们在访问一些页面第一次访问会比较慢，但是第二次访问却很快的原因所在。 307 Temporary Redirect 这个其实和302是一样的，都是临时重定向。在HTTP标准里，当你是采用POST请求时，如果返回的是302状态码，标准是禁止将POST改成了GET请求，但是很多浏览器在实现时并没有按照标准走，很多时候重定向时会将你原先的POST请求方式改为GET方式请求新的URI地址。307状态码会严格遵照标准，不会将请求从POST改为GET，但是实际中，各个浏览器的实现又不尽相同，仍有些浏览器会改为GET。 这个状态码遇到的次数比较少。 4XX 客户端错误 这一系列状态码也是平时遇到比较多的。当出现这个状态码时，错误一般出现在客户端，表示服务器不能正常解析请求。 400 Bad Request 这个状态码的意思是请求报文中存在语法错误，服务器无法理解这个请求。这个错误发生时，我们就要看服务器返回的错误信息是什么，比如“请求缺少了XXX字段”。 401 Unauthorized 该状态的意思是客户端请求时需要进行HTTP认证，也就是我们需要输入用户名和密码进行认证，认证通过了就可以正常请求资源，如果认证失败，请求会再次返回401状态码，并告知认证失败。这时就需要重新请求和重新认证了。 403 Forbidden 该状态表示的意思就是服务器拒绝了客户端请求某一个页面或者资源。比如跨域经常就会出现这样一个状态码。其实就是没有权限，这时候就需要服务器对当前请求所在的IP或者域名设置白名单或者修改访问权限等。 404 Not Found 浏览器上没有请求所对应的资源 5XX服务器错误 这个状态码的意思就是服务器端出现错误了，可能是处理请求时出现问题，比如程序撰写逻辑不对进入死循环，也有可能是服务器挂了。 500 Internal Server Error 该状态吗表示服务器在处理请求时出现了问题。这些问题可能是web应用存在bug，也可能是某些临时的故障，比如内存爆了。此时我们可以查看服务器相关日志的信息，以便更快的定位问题并解决问题。 503 Service Unavailable 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先知道解除以上状况需要的时间，建议写入Retry-After首付字段返回给客户端。 以上就是我们常见的14种状态码，其实学习起来很快，加上项目中遇到的错误，平时有意的去注意出现错误时返回的状态码并去定位问题，久而久之这些状态码肯定了然于胸了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解剖jQuery源码系列之jQuery工具方法]]></title>
      <url>%2F2017%2F05%2F23%2FjQuery20170523%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[解剖jQuery源码系列之jQuery.prototype.init方法]]></title>
      <url>%2F2017%2F05%2F20%2FjQuery20170520%2F</url>
      <content type="text"><![CDATA[今天日子是5月20号，比较特殊，原本打算出去浪一下，奈何对象有事。就静下心来把jQuery源码中的init方法总结下。篇幅会略长些。 jQuery.prototype.init 说起jQuery.prototype.init这个方法，不知道大家还有没有印象，这个方法在jQuery源码中出现在两个地方，什么作用呢？我们来看以下的代码：12345678910//这里出现了第一次jQuery = function( selector, context ) &#123; return new jQuery.fn.init( selector, context, rootjQuery );&#125;//这里是第二次jQuery.fn = jQuery.prototype = &#123; init: function( selector, context, rootjQuery ) &#123; //中间省略无数代码，一会再来看 &#125;&#125; 从上可以看出来，init方法是jQuery原型上的一个方法。那这个具体有什么作用？我们再来看下我们平时使用jQuery或者$创建jQuery对象有几种使用方式，大致可以分为以下123456789101112//$就是jQuery//第一种分类$(""), $(null), $(undefined), $(false)//第二种分类$('#div1') $('.box') $('div') $('#div1 div.box')$('&lt;li&gt;') $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') $('&lt;li&gt;hhehe')//第三种分类$(this) $(document)//第四种分类$(function()&#123;&#125;)//第五种分类$([]) $(&#123;&#125;) 看到这里，可能会有点疑惑，这个跟init方法有什么关系，我们来看一个例子：$(‘#div1’)，当执行这段代码时，$也就是jQuery函数就会执行起来，传入参数，其中selector就是#div1，传入到函数体内后，selector参数传给了jQuery.fn.init( selector, context, rootjQuery )这个构造函数，并new一个这个构造函数的实例，new一个时就会执行init的方法，最终$(‘#div1’)返回的是init的一个实例对象。从以上逻辑可以看出init方法主要做的是根据$或者jQuery构造函数执行时传入不同参数做差异化处理后返回init实例。根据我们平时使用的，$(‘#div’)的作用在于选中页面id为div的元素，而selector由上面的代码可以看出，可以传入不同的参数，那么init方法是如何针对传入的不同selector参数选中不同的Dom元素或者执行某个函数或者做其他处理呢？我们来看下init方法的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127jQuery.fn = jQuery.prototype = &#123; //传入三个参数，其中selector作为选择器元素， //context为selector的执行上下文，rootjQuery就是$(document) init: function( selector, context, rootjQuery ) &#123; // 方法进来定义两个变量，第一个变量是后续匹配selector为字符串时使用 // 第二个参数主要用于存储document.getElementById获取到的Dom元素 var match, elem; // 第一种分类处理: $(""), $(null), $(undefined), $(false) // 如果传进来的是这四种情况直接返回this，关于this是什么可往下看 if ( !selector ) &#123; return this; &#125; // 第二种分类处理： // $('#div1') $('.box') $('div') $('#div1 div.box') // $('&lt;li&gt;') $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') $('&lt;li&gt;hhehe') // 判断传进来的selector，例如$('#div1')，那么selector就是'#div1' // 如果判断为真则进入if语句，否则进入第94行的else if // 也就是我们上面分类的第二类可以进入 if ( typeof selector === "string" ) &#123; // 第二种分类进来后，再次筛选，判断是否是标签 // 能进入if的有$('&lt;li&gt;') $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') // 而我们知道这2种类型属于创建标签 if ( selector.charAt(0) === "&lt;" &amp;&amp; selector.charAt( selector.length - 1 ) === "&gt;" &amp;&amp; selector.length &gt;= 3 ) &#123; // 进入if后给match赋值一个数组，这个数组最终编程是 // match = [ null, '&lt;li&gt;', null ]; // match = [ null, '&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;' , null ]; match = [ null, selector, null ]; &#125; else &#123; // 能进入else的有 // $('#div1') $('.box') $('div') $('#div1 div.box') $('&lt;li&gt;hhehe') // 这一部分后面有写，可翻到后面看 // 最终match由两个取值 // $('#div1')对应的match=[‘#div1’, null, ’div1‘] // $('&lt;li&gt;hhehe')对应的match为match=[‘&lt;li&gt;hhehe’, ‘&lt;li&gt;’, null] // $('.box') $('div') $('#div1 div.box')对应的match为null match = rquickExpr.exec( selector ); &#125; // 判断match是否存在，并且 match[1]存在或者不存在context这个执行上下文 // 能进入if的有 $('&lt;li&gt;') $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') $('&lt;li&gt;hhehe')这种属于match存在并且match[1]也存在 // 还有$('#div1')，这种属于match存在，match[1]不存在，因为我们通过id获取元素是不需要执行上下文，因此context不需要传，为undefined，因此!context为真 if ( match &amp;&amp; (match[1] || !context) ) &#123; // 能通过if的有$('&lt;li&gt;') $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') $('&lt;li&gt;hhehe') if ( match[1] ) &#123; // 这段三目判断的原因在于我们在写创建标签时可以由如下两种写法(因为创建标签只能是通过document创建，所以执行上下文只能是document) // 第一种$('&lt;li&gt;','document') // 第二种$('&lt;li&gt;',$('document')) // 所以先判断执行上下文context是不是JQuery类型，也就是$('&lt;li&gt;',$('document'))这种情况，此时返回context[0]也就是$('document')[0]，其实就是'document' // 如果不是jQuery类型那么直接返回执行上下文context，也就是$('&lt;li&gt;','document')这种情况 context = context instanceof jQuery ? context[0] : context; // 这一块代码涉及到两个JQuery工具方法 // jQuery.merge:合并数组使用的，如果第一个传参是this这种对象，那就是合并对象 // jQuery.parseHTML:将Dom字符串转成数组，例如'&lt;li&gt;1&lt;/li&gt;'转完之后变成['li'] // 后续篇幅有分析这两个方法 // 最终的生成this对象，也就是jQuery对象 // $('&lt;li&gt;') $('&lt;li&gt;hhehe')对应的this对象为&#123;0:'li',length:1,...其他属性&#125; // $('&lt;li&gt;')对应的this对象为&#123;0:'li',1:'li',length:2,...其他属性&#125; jQuery.merge( this, jQuery.parseHTML(match[1],context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,true)); // 创建标签带属性，只支持单标签$('&lt;li&gt;') $('&lt;li&gt;1&lt;/li&gt;')例如 $('&lt;li&gt;',&#123;title:'hi',html:'abcd'&#125;) // rsingleTag.test( match[1] ) 是否是单标签，如果是判断context是不是对象字面量，如果是才走if if ( rsingleTag.test( match[1] ) &amp;&amp; jQuery.isPlainObject( context ) ) &#123; // for in循环下context这个对象字面量，给选中的元素添加上属性 for ( match in context ) &#123; // 判断context中的属性是不是JQuery的工具方法，如果是调用工具方法，传入这个属性的值给这个工具方法，如上面这里例子中的html属性 if ( jQuery.isFunction( this[ match ] ))&#123; // 相当于$('li').html('abcd') this[ match ]( context[ match ] ); // 如果不是方法，那么直接走JQuery的工具方法attr，传入属性和属性值 &#125; else &#123; // 相当于$('li').attr('title','hi') this.attr( match, context[ match ] ); &#125; &#125; &#125; // 最后返回处理后的this对象，也就是JQuery对象 return this; // 处理的是: $('#div1') &#125; else &#123; // 通过原生的document.getElementById获取id所对应的Dom元素 elem = document.getElementById( match[2] ); // 这个是兼容处理，这个兼容处理可忽略 // 以下语句走完,例如有一个ul，id为ul，则this对象为&#123;ul#ul,length:1,context:document,selector:'#ul'&#125; if ( elem &amp;&amp; elem.parentNode ) &#123; this.length = 1; this[0] = elem; &#125; this.context = document; this.selector = selector; return this; &#125; // 以下开始处理: $('.box') $('div') $('#div1 div.box') // 判断context存在不，不存在可以进入if里，如果存在，还需要判断是不是jQuery对象 &#125; else if ( !context || context.jquery ) &#123; // 以下语句等价于 // $('.box'):$(document).find('.box') // $('div'):$(document).find('div') // $('#div1 div.box'):$(document).find('#div1 div.box') // $('.box',$('ul')):$('ul').find('.box') // 其中find方法是sizzle模块中的一个方法 return ( context || rootjQuery ).find( selector ); // 处理比如$('.box','ul') &#125; else &#123; // 等价于$('ul').find('.box') // 其中this.constructor其实就是jQuery构造函数，这也就是为什么在jQuery原型中还需要修正下原型属性constructor指向jQuery构造函数的原因之一 return this.constructor( context ).find( selector ); &#125; // 处理第三种分类: $(document) $(this) // 返回的this对象为&#123;0:document,context:document,length:1&#125; &#125; else if ( selector.nodeType ) &#123; this.context = this[0] = selector; this.length = 1; return this; // 处理第四种分类: $(function()&#123;&#125;) // 以下说明平时我们这么写$(function()&#123;&#125;)和$(document).ready(function()&#123;&#125;)是等价的 &#125; else if ( jQuery.isFunction( selector ) ) &#123; return rootjQuery.ready( selector ); &#125; // 处理 $($("ul")) if ( selector.selector !== undefined ) &#123; this.selector = selector.selector; this.context = selector.context; &#125; // 处理第五种：$(&#123;&#125;),$([]) return jQuery.makeArray( selector, this ); &#125;,&#125; jQuery中的this对象 牵扯到this对象其实就涉及到JavaScript很神奇的this，而我们这边要涉及的是构造函数中的this。例如如下的代码：12345678function demo()&#123; this.name="hehe";&#125;demo.prototype.say()&#123; console.log(this.name);&#125;var demo1=new demo();demo1.say();//此时this指的就是demo1,其实指的就是实例对象 由以上的例子来看jQuery里的this，其实是类似的，它代表的是jQuery的实例对象，例如$(“#div”)这么调用相当于创建了一个jQuery实例对象，也就可以调用jQuery原型对象的各种方法：$(“#div”).html(“hhh”);但是jQuery中的this对象还是有些不一样的，我们举个例子，页面中有3个li标签，那么我们获取这些标签可以这么获取：$(“li”)，此时this对象为1234567this=&#123; 0:'li', 1:'li', 2:'li', length:3, 其他属性...&#125; jQuery.parseHTML方法 这里不涉及这个方法的源码分析，先说下其是做什么用的，有几种用法。1234567var str = '&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;script&gt;alert(4)&lt;\/script&gt;';//第一种用法：两个参数，第三个参数默认falsevar arr=jQuery.parseHTML(str,document);console.log(arr);//['li','li','li']//第二种用法：三个参数var arr=jQuery.parseHTML(str,document,true);console.log(arr);//['li','li','li','script'] 从以上可以看出来，jQuery.parseHTML的作用是将字符串的Dom转成数组。 jQuery.merge方法 我们这里也是不涉及jQuery.merge源码，先说下用法。123456789101112131415161718192021222324var arr1=[1,2];var arr2=[3,4];var obj1=&#123; 0:1, 1:2, length:2&#125;var obj2=&#123; 0:3, 1:4, length:2&#125;//第一种用法：合并数组var arr=jQuery.merge(arr1,arr2);console.log(arr);//[1,2,3,4]//第二种用法：生成一个类似我们上面说的this格式的对象var obj=jQuery.merge(obj1,arr2);console.log(obj);//&#123;0:1,1:2,2:3,3:4,length:4&#125;//另一种写法var obj=jQuery.merge(arr2,obj1);console.log(obj);//&#123;0:3,1:4,2:1,3:2,length:4&#125;//最后一种写法var obj=jQuery.merge(obj1,obj2);console.log(obj);//&#123;0:1,1:2,2:3,3:4,length:4&#125; 作用的话用法里已经说明了。看到这里在回过头来看init中怎么调用它，最后产生什么的结果就比较好理解了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈项目中经常需要使用到的less功能]]></title>
      <url>%2F2017%2F04%2F27%2Fless%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[从统计分析自动生成系统看gulp的自动化构建]]></title>
      <url>%2F2017%2F04%2F27%2Fgulp%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6基础项目构建]]></title>
      <url>%2F2017%2F04%2F27%2Fes6%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[解剖jQuery源码系列之JQuery构造函数]]></title>
      <url>%2F2017%2F04%2F27%2Fjquery20170427%2F</url>
      <content type="text"><![CDATA[jQuery从2006年由John Resig等人创建一直风靡到今天，每个在使用jQuery时，应该都深深的被其便捷性的Dom操作，数据缓存，异步操作等折服，jQuery的api设计让我们可以如此的简单自如的操作web界面，如果你没有感受到，那你应该面壁思过下。 jQuery整体架构 说到jQuery的架构，可以点击右边图片来感受下： 其实jQuery的整体架构还是很清晰（虽然各个模块具体源码看起来感觉也挺乱的）。通过这张图我们大概可以把jQuery分为18块内容。整个jQuery最核心的代码用匿名函数包起来，具体可参考上一篇文章：解剖JQuery源码系列之匿名函数自执行 接着上一篇我们继续来说，这个主要是因为ES5中只有函数作用域和全局作用域，并无块级作用域。jQuery设计时为了不影响全局作用域，以及不同脚本文件引入后互相影响，选择了匿名函数，我们都知道匿名函数自执行（也就是Immediately-Invoked Function Expression (IIFE)），函数体定义的变量以及函数属于局部变量和局部函数，不会影响到全局作用域里定义的同名变量和函数。全局作用域也访问不到这些局部变量和函数，有点类似私有的意味。jQuery设计者也是基于此而采用这种方式。 那么问题来了，既然匿名函数里的变量和函数全局作用域访问不到，那么我们平时为什么可以直接在我们的js中引用jQuery的各种方法呢？我们来看如下的代码：12345678910111213141516171819//jQuery2.0.3版本//这个就是jQuery匿名函数(function( window, undefined ) &#123; //判断是nodejs等common.js（CMD）规范的环境 if ( typeof module === "object" &amp;&amp; module &amp;&amp; typeof module.exports === "object" ) &#123; //通过exports导出 module.exports = jQuery;&#125; else &#123; //判断是否是AMD这种模块化环境 if ( typeof define === "function" &amp;&amp; define.amd ) &#123; //定义jquery模块 define( "jquery", [], function () &#123; return jQuery; &#125; ); &#125;&#125; //if判断主要是确定下window和window.document是不是对象，也就是不是AMD、CMD等模块化环境，如果是对象就把JQuery挂载到全局对象window上 if ( typeof window === "object" &amp;&amp; typeof window.document === "object" ) &#123; window.jQuery = window.$ = jQuery;//秘密就在这一行代码。 &#125;&#125;)( window );123456789101112131415161718192021222324252627282930313233//jQuery3.2.1版本//这个就是jQuery匿名函数( function( global, factory ) &#123; "use strict"; //这是判断如果是nodejs环境的导出方式 //与2.0.3版本的区别就是module.exports导出的不是jQuery构造函数， //而是factory这个函数，也就是我们匿名函数传参的第二个参数function( window, noGlobal) &#123;&#125; if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" ) &#123; module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( "jQuery requires a window with a document" ); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;&#125;)( typeof window !== "undefined" ? window : this, function( window, noGlobal ) &#123; //判断如果是AMD模块化的环境就走if里的语句定义一个jquery模块 if ( typeof define === "function" &amp;&amp; define.amd ) &#123; define( "jquery", [], function() &#123; return jQuery; &#125; ); &#125; //这个判断上一篇文章已有涉及，这里就不在赘述 if ( !noGlobal ) &#123; window.jQuery = window.$ = jQuery; &#125; return jQuery;&#125;); 我们之所以可以在全局作用域里自如的使用的jQuery的方法，是因为如上代码的，将jQuery这个构造函数根据不同环境采用不同的方式引用（为什么说是构造函数，我们后续再分析），例如：挂载在全局对象window上，这样我们在任何js文件里都可以引用jQuery的方法了。（看到这里估计你还是晕的，没关系，再往下看你就明白了。） jQuery构造函数 在分析jQuery构造函数，我们先来看下原生js中的面向对象，以下是我们一般在写面向对象的写法：1234567891011121314//这个就是构造函数（说白点就是函数）function suhq()&#123; //这里写一些实例属性和方法，非共享。&#125;//通过在suhq的原型（suhq.prototype）上写些suhq实例共享的属性和方法suhq.prototype.init=function()&#123; //这里主要是new一个新实例时需要初始化的相关内容。&#125;//这个就是实例共享的方法suhq.prototype.say=function()&#123; &#125;var s1=new suhq();//创建实例s1.init();//初始化s1.say();//调用原型上的共享方法 其实，js中是没有如同java中类这种面向对象语法的（ES6引入了），那js中是如何实现面向对象的呢？如上代码所示，js是通过原型来模拟java中类的行为，然后new一个实例出来，这个实例不仅可以拥有构造函数的实例属性，也可以访问原型上的共享属性与方法。如果jQuery按照这样写的应该如何写？123456function jQuery()&#123;&#125;jQuery.prototype.init=function()&#123;&#125;jQuery.prototype.say=function()&#123; &#125; 接下去调用的方法和上面是一样的，但是我们用过jQuery都知道jQuery是这么调用的，例如$().say()或者jQuery().say()或者$.each()，那jQuery是如何写的呢？我们来看如下的代码：123jQuery = function( selector, context ) &#123; return new jQuery.fn.init( selector, context, rootjQuery );&#125; jQuery的写法和我们一般写面向对象不太一样，为什么这么说呢？我们来看下jQuery构造函数里返回的是什么？返回的是jQuery.fn.init()这个init构造函数的实例，看到这一句，是不是有点懵逼，按照js原生面向对象的写法，jQuery构造函数应该是在这个函数里写一些实例独有的属性与方法，为什么直接返回这么一个实例对象？而且我们平时调用jQuery的API时明明是这么调用的，例如：$(‘div’).css(“background”,”red”);，再比如:$.each(function(item){});等，按照这样的调用方法，第一种调用看起来像是调用的是原型上的方法，第二种看起来像是调用构造函数的实例方法。可源码中写的却是返回这么一个实例。而且我们调用API貌似都没new一下产生实例对象，就能调用jQuery的各种API，是不是感觉很神奇，其实这恰恰是JQuery能这么火的原因之一。这个我们叫做jQuery无new操作。接下去我们来分析，jQuery是如何做到这一点的。 jQuery无NEW操作符 我们在前面写的suhq这个构造函数，调用时需要new suhq()一下产生一个suhq的实例对象，而我们平时在调用时却不需要，原因是因为jQuery构造函数里写的这么一句话1234 jQuery = function( selector, context ) &#123; //就是这一句代码 return new jQuery.fn.init( selector, context, rootjQuery );&#125; 那是因为从jQuery构造函数中的代码可以看出jQuery已经帮我们做了这么一个new操作了。但是new的却是init的实例对象，而不是jQuery的实例，那么我们平时调用时是如何能访问到jQuery原型上的方法呢？为了更好的理解这个意思，我们举个例子，比如：$(“div”).css(“background”,”red”)其中”div”就是selector参数的实参，执行$(“div”)这个操作（按照jQuery构造函数写的）返回的是init构造函数的一个实例对象，那么css这个方法要么是init构造函数的实例方法或者是原型方法，但是我们如果稍微了解下jQuery如何写插件和扩展方法就知道，css这个方法其实是jQuery原型上的一个方法。其实，奥秘就在如下代码中：123//这是一段在匿名函数中的两行代码jQuery.fn = jQuery.prototype = &#123;&#125;;jQuery.fn.init.prototype = jQuery.fn; 第一句是jQuery.fn指向了jQuery.prototype，话句话说fn就是prototype，第二句是jQuery.fn.init的原型指向了jQuery.fn也就是指向了jQuery.prototype，简单点就是init构造函数被重写成了jQuery的原型，所以init的实例对象才能访问到jQuery对象的属性与方法（因为构造函数new一个对象时就会在实例对象上创建一个属性(proto)指向原型，我们在访问实例对象的属性或者方法时，如果实例对象本身没有，就会朝着(proto)指向的原型上找）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解剖jQuery源码系列之匿名函数自执行]]></title>
      <url>%2F2017%2F04%2F25%2Fjquery20170425%2F</url>
      <content type="text"><![CDATA[最近公司开始逐步放弃掉了支持IE8，转而从IE9支持起，jQuery版本也从1.8.0开始需要升级到2.0+以上，工作中用到jQuery也蛮多的，刚好最近不是很忙打算梳理下jQuery的相关内容。 相比于最近前端界流行的vue、react、angular等等框架，jQuery的热度再也不像之前那么火热，甚至有种被遗弃的感觉，很多人开口闭口都是各种新出的框架。记得老大说过，技术其实要适应生产环境才是最重要的。很多时候在工作中遇到问题更多的是基础的问题，远远谈不到这个框架的优劣。ES5仍然博大精深。本系列主要分析jQuery2.0.3版本，也会加上最新版jQuery3.2.1的相应解剖。 框架总有过时的时候，基础才是真材实料。 jQuery2.0.3匿名函数 其实，开始看jQuery源码，真的蛮头疼的，细细品味下来，再结合工作中遇到的各种坑。体会还是蛮多的，以下是2.0.3版本源码抽出来的，整个源码就是包在一个匿名函数里，让这个匿名函数自执行。说到匿名函数，我们首先要知道js中定义函数的几种方式（顺便复习下基础）： 第一种，经常使用，比较常规：123function func(a)&#123; console.log(a)&#125; 第二种，利用构造函数Function，需要传入两个参数：1.函数参数列表2.函数体。这种写法在函数体很多的时候特别不方便，不建议这么写。1var func=new Function(a,'console.log(a);') 第三种，匿名函数定义赋给变量123var func=function(a)&#123; console.log(a);&#125; 了解了js中函数的定义的几种方法，我们再来看下匿名函数自执行的几种定义形式。1234567891011121314151617181920//1.jQuery的写法(function( window, undefined ) &#123; //这边是jQuery的核心代码&#125;)( window );//2.其他写法，这种写法在IE8下会出现问题，undefined可以定义为变量，修改成其他值。IE9以上和高级浏览器，undefined都不可以修改。(function( window,undefined) &#123; //这边是jQuery的核心代码&#125;)( window, undefined);//3.这种写法和第一种其实是一样的。(function( window, undefined) &#123; //这边是jQuery的核心代码&#125;( window)); 从以上来看，匿名函数自执行简单的说就是定义一个匿名函数，然后立即执行，在原生js里的语法是把匿名函数包在一对()里，然后按照函数的正常调用传参数即可，jQuery就是采用这种方式，匿名函数传了一个实参window，为什么要传window这个全局对象呢？其实这个跟我们js查找变量所走的作用域有关系，分析后主要有2个原因： 1.匿名函数里用到window这个全局对象，不需要沿着作用域一层层往上去查找，直接在传参中获取，提高了获取window对象的速度。 2.方便压缩，实参传入形参（普及下实参和形参的概念，实参就是你传入函数实际传入的值，形参就是你定义函数时，函数的参数。），形参就可以直接压缩成一个字母w。 那为什么jQuery匿名函数还要传入第二个参数呢？我也总结了有两个原因： 1.匿名函数内部需要用到，undefined的值，可以从变量的角度来理解，因为匿名函数自执行时并没有传这个参数，函数中没有传参数，这个值默认为undefined。相比较第2种写法，undefined放在函数的形参里，实参不传，主要是为了兼容IE下的bug：可以定义undefined并修改它的值。 2.方便压缩成字母u。 jQuery3.2.1架构（最新版） 这个版本的整体写法改了风格，但是其实内容和原理变化不大，主要做了兼容Node、sea.js等符合Common.js规范或者类似Common.js规范的js框架。123456789101112131415161718192021222324(function( global, factory ) &#123; if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" ) &#123; // For CommonJS and CommonJS-like environments where a proper window is present, // execute the factory and get jQuery // For environments that do not inherently posses a window with a document // (such as Node.js), expose a jQuery-making factory as module.exports // This accentuates the need for the creation of a real window // e.g. var jQuery = require("jquery")(window); // See ticket #14549 for more info module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( "jQuery requires a window with a document" ); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;// Pass this if window is not defined yet&#125;(typeof window !== "undefined" ? window : this, function( window, noGlobal ) &#123; //说白了这里就是写各种JQ各种功能函数的地方，大概有一万多行&#125;)); 最新版的jQuery写法稍微修改了下，其实大体是一样的，我们先简化如下所示：123(function( global, factory ) &#123; //这里先不看&#125;(a,b); 整个函数就是个匿名函数自执行。其中， a参数为三目运算（typeof window !== “undefined” ? window : this），这个是判断当前运行环境是否支持window这个全局对象，主要是为了兼容node.js等类似common.js规范环境，例如nodejs中的全局对象是global，当nodejs某一个模块不支持window时，这个参数就是this也就是global。 b参数为:123function( window, noGlobal ) &#123; //说白了这里就是写各种JQ各种功能函数的地方，大概有一万多行&#125; 分析了下这两个参数，我们再来看下这个匿名函数的函数体。首行的判断语句：if ( typeof module === “object” &amp;&amp; typeof module.exports === “object” ) 。玩过node.js就知道module和module.exports就是nodejs用来创建模块并输出模块对象的方法。若此条件成立，if里执行的代码就是用来兼容nodejs。我们来看支持的情况下：123456789101112&#123; module.exports = global.document ? //三目运算符，先判断当前环境是否支持window.document属性 //（注意我们上面提到过形参global的实参是window） factory( global, true ) : //支持的话就好办啦，常规的浏览器一般都是支持的，那就直接module.exports = factory( global, true )， //把JQ后面那一万多行的功能函数扩展到node.js里面。（注意我们上面提到过形参factory的实参是实现JQ各种功能的一个外部函数） function( w ) &#123; //如果当前环境不支持window.document属性，那就写个函数扔个Error说这环境不适用JQ，但依旧返回JQ的功能函数（但大部分估计是不能用的了） if ( !w.document ) &#123; throw new Error( "jQuery requires a window with a document" ); &#125; return factory( w ); &#125;;&#125; 如果我们使用的环境不是node.js等类似common.js规范环境，那么if ( typeof module === “object” &amp;&amp; typeof module.exports === “object” ) 这个判断就为false，走else，直接执行factory( global ); 看到以上的分析，是否有一个参数，大家会觉得略奇怪些：noGlobal，这个是做什么用的？全局搜索了下jQuery源码，发现有用到的地方就是如下了：123456// Expose jQuery and $ identifiers, even in AMD// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)// and CommonJS for browser emulators (#13566)if ( !noGlobal ) &#123; window.jQuery = window.$ = jQuery;&#125; 当noGlobal为假（也就是浏览器环境）时才执行if里的语句，把jQuery挂载在window下，从以上代码我们也可以看出来，jQuery和$是等价的，都指向jQuery对象。如果为真（那就是类似nodej或者其他类似AMD和CommonJS的环境里），就不执行if里的语句，那么其他环境如何使用到jQuery的相关方法呢？在整个源码的最后有一句代码：return jQuery;根据前面分析的匿名函数传参以及return jQuery;这一句代码，我们在nodejs环境中应该按照如下的方式调用(当然如果你改写了下jQuery那也可以用别的方式引入，这边就不说了)：1var $=require('jquery')(window); 以上就是这两个版本中采用的匿名函数自执行。当然采用匿名函数自执行最大的目的就是匿名函数内部都是局部变量，不会污染全局作用域。当页面引用多个库时也能很好的避免变量重名，函数重名等等一系列问题。 此篇分享先到此，接下去还会其他系列的分享。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[点滴的生活就是幸福]]></title>
      <url>%2F2017%2F04%2F24%2FsinFuture%2F</url>
      <content type="text"><![CDATA[我把我新博客第一篇文章给了人生中最重的事！]]></content>
    </entry>

    
  
  
</search>
