<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[浅谈项目中经常需要使用到的less功能]]></title>
      <url>%2F2017%2F04%2F27%2Fless%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[从统计分析自动生成系统看gulp的自动化构建]]></title>
      <url>%2F2017%2F04%2F27%2Fgulp%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6基础项目构建]]></title>
      <url>%2F2017%2F04%2F27%2Fes6%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[解剖JQuery源码系列之JQuery构造函数]]></title>
      <url>%2F2017%2F04%2F27%2Fjquery20170427%2F</url>
      <content type="text"><![CDATA[JQuery从2006年由John Resig等人创建一直风靡到今天，每个在使用JQuery时，应该都深深的被其便捷性的Dom操作，数据缓存，异步操作等折服，JQuery的api设计让我们可以如此的简单自如的操作web界面，如果你没有感受到，那你应该面壁思过下。 JQuery整体架构 说到JQuery的架构，可以点击右边图片来感受下： 其实JQuery的整体架构还是很清晰（虽然各个模块看起来感觉也挺乱的）。通过这张图我们大概可以把JQuery分为18块内容。整个JQuery最核心的代码用匿名函数包起来，这个主要是因为ES5中只有函数作用域和全局作用域，并无块级作用域。JQuery设计时为了不影响全局作用域，以及不同脚本文件引入后互相影响，选择了匿名函数，我们都知道匿名函数自执行（也就是Immediately-Invoked Function Expression (IIFE)），函数体定义的变量以及函数属于局部变量和局部函数，不会影响到全局作用域里定义的同名变量和函数。全局作用域也访问不到这些局部变量和函数，有点类似私有的意味。JQuery设计者也是基于此而采用这种方式。 那么问题来，既然匿名函数里的变量和函数全局作用域访问不到，那么我们平时为什么可以直接在我们的js中引用JQuery的各种方法呢？我们来看如下的代码：1234567//这个就是jQuery匿名函数(function( window, undefined ) &#123; //这是匿名函数体内的一段代码，这个if判断其实主要是确定下window和window.document是不是对象其实也就是判断是不是浏览器环境啦，如果是才把JQuery挂载上去 if ( typeof window === "object" &amp;&amp; typeof window.document === "object" ) &#123; window.jQuery = window.$ = jQuery;//秘密就在这一行代码。 &#125;&#125;)( window ); 我们之所以可以在全局作用域里自如的使用的JQuery的方法，是因为如上代码的第3行，将JQuery这个构造函数（为什么说是构造函数，我们后续再分析）挂载在全局对象window上，这样我们在任何js文件里都可以引用JQuery的方法了。（看到这里估计你还是晕的，没关系，再往下看你就明白了。） JQuery构造函数 在分析JQuery构造函数，我们先来看下原生js中的面向对象，以下是我们一般在写面向对象的写法：1234567891011121314//这个就是构造函数（说白点就是函数）function suhq()&#123; //这里写一些实例属性和方法，非共享。&#125;//通过在suhq的原型（suhq.prototype）上写些suhq实例共享的属性和方法suhq.prototype.init=function()&#123; //这里主要是new一个新实例时需要初始化的相关内容。&#125;//这个就是实例共享的方法suhq.prototype.say=function()&#123; &#125;var s1=new suhq();//创建实例s1.init();//初始化s1.say();//调用原型上的共享方法 其实，js中是没有如同java中类这种面向对象语法的（ES6引入了），那js中是如何实现面向对象的呢？如上代码所示，js是通过原型来模拟java中类的行为，然后new一个实例出来，这个实例不仅可以拥有构造函数的实例属性，也可以访问原型上的共享属性与方法。如果JQuery按照这样写的应该如何写？123456function jQuery()&#123;&#125;jQuery.prototype.init=function()&#123;&#125;jQuery.prototype.say=function()&#123; &#125; 接下去调用的方法和上面是一样的，但是我们用过JQuery都知道JQuery是这么调用的，例如$().say()或者jQuery().say()或者$.each()，那JQuery是如何写的呢？我们来看如下的代码：123jQuery = function( selector, context ) &#123; return new jQuery.fn.init( selector, context, rootjQuery );&#125; JQuery的写法和我们一般写面向对象不太一样，为什么这么说呢？我们来看下JQuery构造函数里返回的是什么？返回的是jQuery.fn.init()这个init构造函数的实例，看到这一句，是不是有点懵逼，按照js原生面向对象的写法，JQuery构造函数应该是在这个函数里写一些实例独有的属性与方法，为什么直接返回这么一个实例对象？而且我们平时调用JQuery的API时明明是这么调用的，例如：$(‘div’).css(“background”,”red”);，再比如:$.each(function(item){});等，按照这样的调用方法，第一种调用看起来像是调用的是原型上的方法，第二种看起来像是调用构造函数的实例方法。可源码中写的却是返回这么一个实例。而且我们调用API貌似都没new一下产生实例对象，就能调用JQuery的各种API，是不是感觉很神奇，其实这恰恰是JQuery能这么火的原因之一。这个我们叫做JQuery无new操作。接下去我们来分析，JQuery是如何做到这一点的。 JQuery无NEW操作符 我们在前面写的suhq这个构造函数，调用时需要new suhq()一下产生一个suhq的实例对象，而我们平时在调用时却不需要，原因是因为JQuery构造函数里写的这么一句话123 jQuery = function( selector, context ) &#123; return new jQuery.fn.init( selector, context, rootjQuery );&#125; 为什么没有new一个对象，那是因为从jQuery构造函数中的代码可以看出jQuery已经帮我们做了这么一个new操作了。但是new的却是init的实例对象，而不是jQuery的实例，那么我们平时调用时是如何能访问到jQuery原型上的方法呢？为了更好的理解这个意思，我们举个例子，比如：$(“div”).css(“background”,”red”)其中”div”就是selector参数的实参，执行$(“div”)这个操作（按照JQuery构造函数写的）返回的是init构造函数的一个实例对象，那么css这个方法要么是init构造函数的实例方法或者是原型方法，但是我们如果稍微了解下JQuery如何写插件和扩展方法就知道，css这个方法其实是JQuery原型上的一个方法。其实，奥秘就在如下代码中：123//这是一段在匿名函数中的两行代码jQuery.fn = jQuery.prototype = &#123;&#125;;jQuery.fn.init.prototype = jQuery.fn; 第一句是jQuery.fn指向了jQuery.prototype，话句话说fn就是prototype，第二句是jQuery.fn.init的原型指向了jQuery.fn也就是指向了jQuery.prototype，简单点就是init构造函数被重写成了jQuery的原型，所以init的实例对象才能访问到jQuery对象的属性与方法（因为构造函数new一个对象时就会在实例对象上创建一个proto属性指向原型，我们在访问实例对象的属性或者方法时，如果实例对象本身没有，就会朝着proto指向的原型上找）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解剖JQuery源码系列之匿名函数自执行]]></title>
      <url>%2F2017%2F04%2F25%2Fjquery20170425%2F</url>
      <content type="text"><![CDATA[最近公司开始逐步放弃掉了支持IE8，转而从IE9支持起，JQuery版本也从1.8.0开始需要升级到2.0+以上，工作中用到JQuery也蛮多的，刚好最近不是很忙打算梳理下JQuery的相关知识。 相比于最近前端界流行的vue、react、angular等等框架，JQuery的热度再也不像之前那么火热，甚至有种被遗弃的感觉，很多人开口闭口都是各种新出的框架。记得老大说过，技术其实要适应生产环境才是最重要的。很多时候在工作中遇到问题更多是基础的问题，远远谈不到这个框架的优劣。ES5仍然博大精深。本系列主要分析JQuery2.0.3版本，也会加上最新版JQuery的相应解剖。 框架总有过时的时候，基础才是真材实料。所以我们来复习下基础吧！ JQuery2.0.3架构 其实，开始看JQuery源码，真的蛮头疼的，细细品味下来，再结合工作遇到的各种坑。体会还是蛮多的，以下是2.0.3版本源码抽出来的，整个源码就是包在一个匿名函数里，让这个匿名函数自执行。说到匿名函数，我们先来看看函数定义的几种方式： 第一种，经常使用，比较常规：123function func(a)&#123; console.log(a)&#125; 第二种，利用构造函数Function，需要传入两个参数：1.函数参数列表2.函数体。这种写法在函数体很多的时候特别不方便，不建议这么写。1var func=new Function(a,'console.log(a);') 第三种，匿名函数定义赋给变量123var func=function(a)&#123; console.log(a);&#125; 了解了函数的定义方法，我们再来看下匿名函数的其他定义形式。1234567891011121314151617181920//1.JQuery的写法(function( window, undefined ) &#123; //这边是JQuery的核心代码&#125;)( window );//2.其他写法，这种写法在IE8下会出现问题，undefined可以定义为变量，修改成其他值。(function( window) &#123; //这边是JQuery的核心代码&#125;)( window, undefined);//3.这种写法和第一种其实是一样的。(function( window, undefined) &#123; //这边是JQuery的核心代码&#125;( window)); 从以上来看，JQuery写法比较好，匿名函数传了一个实参window，为什么要传window这个全局对象呢？其实这个跟我们js查找变量所走的作用域有关系，分析后主要有2个原因： 1.匿名函数里用到window这个全局对象，不需要沿着作用域一层层往上去查找，直接在传参中获取，提高了获取window对象的速度。 2.方便压缩，实参传入形参（普及下实参和形参的概念，实参就是你传入函数实际传入的值，形参就是你定义函数时，函数的参数。），形参就可以直接压缩成一个字母w。 那为什么JQuery匿名函数还要传入第二个参数呢？我也总结了有两个原因： 1.匿名函数内部需要用到，undefined的值，可以从变量的角度来理解，因为匿名函数自执行时并没有传这个参数，函数中没有传参数，这个值默认为undefined。相比较第2中写法，undefined放在函数的形参里，主要是为了兼容IE下的bug：可以定义undefined并修改它的值。 2.方便压缩成字母u。 JQuery3.2.1架构（最新版） 这个版本的整体写法改了风格，但是其实内容和原理变化不大，主要做了兼容Node、sea.js等符合Common.js规范或者类似Common.js规范的js框架。123456789101112131415161718192021222324(function( global, factory ) &#123; if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" ) &#123; // For CommonJS and CommonJS-like environments where a proper window is present, // execute the factory and get jQuery // For environments that do not inherently posses a window with a document // (such as Node.js), expose a jQuery-making factory as module.exports // This accentuates the need for the creation of a real window // e.g. var jQuery = require("jquery")(window); // See ticket #14549 for more info module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( "jQuery requires a window with a document" ); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;// Pass this if window is not defined yet&#125;(typeof window !== "undefined" ? window : this, function( window, noGlobal ) &#123; //说白了这里就是写各种JQ各种功能函数的地方，大概有一万多行&#125;)); 最新版的JQuery写法稍微修改了下，其实大体是一样的，我们先简化如下所示：123(function( global, factory ) &#123; //这里先不看&#125;(a,b); 整个函数就是个匿名函数自执行。其中， a参数为三目运算（typeof window !== “undefined” ? window : this），这个是判断当前运行环境是否支持window这个全局对象，主要是为了兼容node.js等类似common.js规范环境，例如nodejs中的全局对象是global，当nodejs某一个模块不支持window时，这个参数就是this也就是global。 b参数为:123function( window, noGlobal ) &#123; //说白了这里就是写各种JQ各种功能函数的地方，大概有一万多行&#125; 分析了下这个匿名函数，我们再来看下这个匿名函数的函数体。首行的判断语句：if ( typeof module === “object” &amp;&amp; typeof module.exports === “object” ) 。玩过node.js就知道module和module.exports就是nodejs用来创建模块并输出模块对象的方法。若此条件成立，if里执行的代码就是用来兼容nodejs。我们来看支持的情况下：123456789101112&#123; module.exports = global.document ? //三目运算符，先判断当前环境是否支持window.document属性 //（注意我们上面提到过形参global的实参是window） factory( global, true ) : //支持的话就好办啦，常规的浏览器一般都是支持的，那就直接module.exports = factory( global, true )， //把JQ后面那一万多行的功能函数扩展到node.js里面。（注意我们上面提到过形参factory的实参是实现JQ各种功能的一个外部函数） function( w ) &#123; //如果当前环境不支持window.document属性，那就写个函数扔个Error说这环境不适用JQ，但依旧返回JQ的功能函数（但大部分估计是不能用的了） if ( !w.document ) &#123; throw new Error( "jQuery requires a window with a document" ); &#125; return factory( w ); &#125;;&#125; 如果我们使用的环境不是node.js等类似common.js规范环境，那么if ( typeof module === “object” &amp;&amp; typeof module.exports === “object” ) 这个判断就为false，走else，直接执行factory( global ); 以上就是这两个版本中采用的匿名函数自执行。当然采用匿名函数自执行最大的目的就是匿名函数内部都是局部变量，不会污染全局作用域。当页面引用多个库时也能很好的避免变量重名，函数重名等等一系列问题。 此篇分享先到此，接下去还会其他系列的分享。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[点滴的生活就是幸福]]></title>
      <url>%2F2017%2F04%2F24%2FsinFuture%2F</url>
      <content type="text"><![CDATA[我把我新博客第一篇文章给了人生中最重的事！]]></content>
    </entry>

    
  
  
</search>
